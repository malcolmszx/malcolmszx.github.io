---
layout:     post
title:  如何掌握JDK中的线程池
subtitle:  JDK中的线程池
date:       2019-02-15
author:     BY Malcolmszx@gmail.com
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - JDK
    - ThreadPoolExecutor 
---

## 前言

JDK并发包下面的线程池ThreadPoolExecutor是面试中经常被考查的点，ThreadPoolExecutor哪些是应该掌握的？下面抛出了几个问题。

1. ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？
2. ThreadPoolExecutor有哪些状态，状态之间是怎样流转的？
3. ThreadPoolExecutor线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？
4. ThreadPoolExecutor创建的线程哪个时间被启动？
5. ThreadPoolExecutor竟然是线程池那么他是如何做到重复利用线程的？
6. ThreadPoolExecutor创建的同一个线程同一时刻能执行多个任务吗？如果不能是通过什么机制保证ThreadPoolExecutor中的同一个线程只能执行完一个任务，才会执行另一个任务？
7. ThreadPoolExecutor关闭线程池的方法shutdown与shutdownNow的区别是什么？
8. 通过submit方法向ThreadPoolExecutor提交任务后，当所有的任务都执行完后不调用shutdown或shutdownNow方法有问题？
9. ThreadPoolExecutor有没有提供扩展点，方便在任务执行前或执行后做一些事情？

### ThreadPoolExecutor参数有哪些与创建线程策略

ThreadPoolExecutor参数

1. corePoolSize 线程池中核心线程数
2. maximumPoolSize 线程池中最大线程数
3. keepAliveTime 当线程池中线程数量超过corePoolSize时，允许等待多长时间从workQueue中拿任务
4. unit keepAliveTime对应的时间单位，为TimeUnit类。
5. workQueue 阻塞队列，当线程池中线程数超过corePoolSize时，用于存储提交的任务队列。
6. threadFactory 线程池采用，该线程工厂创建线程池中的线程。
7. handler 为RejectedExecutionHandler，当线程线中线程超过maximumPoolSize时采用的，拒绝执行处理器。

创建线程策略

[![](https://blogimg-1256334314.cos.ap-chengdu.myqcloud.com/367eb895-6d1d-40ec-858e-755796aa97d6.png)](https://malcolmszx.github.io/)

简单介绍一下，一个任务提交给线程池后，线程池创建线程来执行提交任务的流程。

1. 当提交任务时，线程池中的来用执行任务的线程数小于corePoolSize（核心线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行第二2步。
2. 当提交任务时，线程池中的来用执行任务的线程数大于corePoolSize（核心线程数），如果workQueue（任务队列）没有满，则线程池会将提交的任务先保存在workQueue，等待线程池中的线程执行完其它已提交任务后会循环从workQueue中取出任务执行。否则执行第3步。
3. 当提交任务时线程池中的来用执行任务大于corePoolSize（核心线程数），且workQueue（任务队列）已满，但没有超过maximunPoolSize（最大线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行4。
4. 当提交任务时，线程池中的来用执行任务的线程数大于maximunPoolSize（最大线程数），执行线程池中配置的拒绝策略（RejectedExecutionHanlder）。

所以在设置ThreadPoolExecutor的参数时一定要特别小心，不建议采用很大的ArrayBlockQueue或不限大小的LinkedBlockQueue，同时corePoolSize也不应该设置过大。CUP密集的任务的话可以设置小一点(CUP数据+1这种)避免不必要的上下文切换；而对于IO密集的任务则corePoolSize则可以设置的大一点，可以避免长时间IO等待而CUP却空闲。threadFactory建议采用自己定义的，让其创建的线程容易区分，方便问题定位。

### 线程池有哪些状态，状态之间流转是什么样子的？


状态流程如下图：

[![](http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg)](https://malcolmszx.github.io/)


1. 新建(new)：新创建了一个线程对象。
2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
3. 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice），执行程序代码。
4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
5. 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 池程池中的线程哪个时间点被创建？

ThreadPoolExecutor中的线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？一般是任务被提交后，线程池会利用线程工厂去创建线程，但当线程池中线程数已为corePoolSize时或maxmumPoolSize时不会。也可以在任务提交前通过prestartCoreThread方法或prestartAllCoreThreads方法预先创建核心线程。具体可以参考这下这个图：

[![](https://blogimg-1256334314.cos.ap-chengdu.myqcloud.com/11d6e62d-bc01-4f0c-8bce-2d69d9788975.png)](https://malcolmszx.github.io/)


### ThreadPoolExecutor中创建的线程哪个时间被启动？

线程池中线程实现是在addWorker方法中被创建的，详见之前文章中addWorker方法分析。创建后完，该线程就被启动。线程池中被创建的线程被封装到了Worker对象中，而Worker类又实现了Runnable接口，线程池中的线程又引用了worker。当线程被start后实际就有机会等待操作系统调度执行Worker类的run方法。

```
Worker(Runnable firstTask) {
  setState(-1); 
  this.firstTask = firstTask;
 //创建的线程引用了worker
  this.thread = getThreadFactory().newThread(this);
}

```

