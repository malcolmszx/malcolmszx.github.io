---
layout:     post
title:  如何掌握JDK中的线程池
subtitle:  JDK中的线程池(http://blog.jobbole.com/104737/)
date:       2019-02-15
author:     BY Malcolmszx@gmail.com
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - JDK
    - ThreadPoolExecutor 
---

## 前言

Java1.5之后，引入的Executor框架的最大优点是把任务的提交和执行解耦，只需把Task描述清楚，然后提交即可。至于这个Task是怎么被执行的，被谁执行的，什么时候执行的，就全部交给线程池管理。

小案例 

```
import java.util.concurrent.*;
 
/**
 * Created by malcolmszx on 2019/02/15.
 */
public class ExecutorTest {
    static ExecutorService executor = Executors.newFixedThreadPool(10);
 
    public static void main(String[] args) throws Exception {
        Future<String> future = executor.submit(new Task());
        String result = future.get();
        System.out.println(result);
    }
 
    static class Task implements Callable<String> {
        @Override
        public String call() throws Exception {
            TimeUnit.SECONDS.sleep(10);
            return "A";
        }
    }
}
```
初始化一个线程池，提交一个任务，主线程的future.get()会阻塞线程直到任务执行完成。

### Executor框架成员

线程池实现框架中包含了一堆实现类，它们之间的关系如下，只有了解了各个类之间的关系，才能方便我们更好的理解线程池的实现。

[![](http://jbcdn2.b0.upaiyun.com/2016/08/b02b59e6133fbc20b0b8ec4c7df8c018.png)](https://malcolmszx.github.io/)

从图中可以看到Executor、ExecutorService、ScheduledExecutorService定义线程池接口，ThreadPoolExecutor和ScheduledThreadPoolExecutor是线程池的实现，前者是一个普通的线程池，后者一个定期调度的线程池，Executors是辅助工具，用以帮助我们快速定义线程池。

JDK并发包下面的线程池ThreadPoolExecutor是面试中经常被考查的点，ThreadPoolExecutor哪些是应该掌握的？下面抛出了几个问题。

1. ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？
2. ThreadPoolExecutor有哪些状态，状态之间是怎样流转的？
3. ThreadPoolExecutor线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？
4. ThreadPoolExecutor创建的线程哪个时间被启动？
5. ThreadPoolExecutor竟然是线程池那么他是如何做到重复利用线程的？
6. ThreadPoolExecutor创建的同一个线程同一时刻能执行多个任务吗？如果不能是通过什么机制保证ThreadPoolExecutor中的同一个线程只能执行完一个任务，才会执行另一个任务？
7. ThreadPoolExecutor关闭线程池的方法shutdown与shutdownNow的区别是什么？
8. 通过submit方法向ThreadPoolExecutor提交任务后，当所有的任务都执行完后不调用shutdown或shutdownNow方法有问题？
9. ThreadPoolExecutor有没有提供扩展点，方便在任务执行前或执行后做一些事情？
10. ThreadPoolExecutor线程池工具类Executors如何快速自定义线程池？

### ThreadPoolExecutor参数有哪些与创建线程策略

ThreadPoolExecutor参数

1. corePoolSize 线程池中核心线程数
2. maximumPoolSize 线程池中最大线程数
3. keepAliveTime 线程活动保持时间。指工作线程空闲后，继续保持存活的时间。默认情况下，这个参数只有在线程数大于corePoolSize时才起作用。所以，如果任务很多，且每个任务的执行时间比较短，可以调大keepAliveTime，提高线程的利用率。
4. workQueue 阻塞队列，当线程池中线程数超过corePoolSize时，用来保存等待执行的任务的阻塞队列。在初始化线程池时，对阻塞队列的选择也很重要，jdk中提供了以下几个阻塞队列：

    1. ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO原则对元素进行排序。
    2. LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序元素，吞吐量通常要高于ArrayBlockingQuene。
    3. SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene。
    4. priorityBlockingQuene：具有优先级的无界阻塞队列。

5. threadFactory 创建线程的工厂。可以通过自定义线程工厂给每个线程设置有意义的名称。

   如guava提供的ThreadFactoryBuilder。
    ```
    new ThreadFactoryBuilder().setNameFormat("XX-task-%d").build();
    ```

6. RejectedExecutionHandler饱和策略。当阻塞队列满了且没有空闲的工作线程，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略在默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。不过，线程池提供了4种策略：

    1. AbortPolicy：直接抛出异常。
    2. CallerRunsPolicy：只用调用者所在的线程来运行任务。
    3. DiscardOldestPolicy：丢弃阻塞队列中最近的一个任务，并执行当前任务。
    4. DiscardPolicy：直接丢弃。

当然，也可以根据应用场景来实现RejectedExecutionHandler接口自定义饱和策略，如记录日志或持久化存储不能处理的任务。

```
public class ThreadPoolExecutor extends AbstractExecutorService {
    // 线程池的控制状态（用来表示线程池的运行状态（整形的高3位）和运行的worker数量（低29位））
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    // 29位的偏移量
    private static final int COUNT_BITS = Integer.SIZE - 3;
    // 最大容量（2^29 - 1）
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
 
    // runState is stored in the high-order bits
    // 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3）
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
    // 阻塞队列
    private final BlockingQueue<Runnable> workQueue;
    // 可重入锁
    private final ReentrantLock mainLock = new ReentrantLock();
    // 存放工作线程集合
    private final HashSet<Worker> workers = new HashSet<Worker>();
    // 终止条件
    private final Condition termination = mainLock.newCondition();
    // 最大线程池容量
    private int largestPoolSize;
    // 已完成任务数量
    private long completedTaskCount;
    // 线程工厂
    private volatile ThreadFactory threadFactory;
    // 拒绝执行处理器
    private volatile RejectedExecutionHandler handler;
    // 线程等待运行时间
    private volatile long keepAliveTime;
    // 是否运行核心线程超时
    private volatile boolean allowCoreThreadTimeOut;
    // 核心池的大小
    private volatile int corePoolSize;
    // 最大线程池大小
    private volatile int maximumPoolSize;
    // 默认拒绝执行处理器
    private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();
    //
    private static final RuntimePermission shutdownPerm =
        new RuntimePermission("modifyThread");
    ...
}
```

创建线程策略

[![](https://liuzhihang.com/resources/concurrent/thread-pool.png)](https://malcolmszx.github.io/)

```
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
　　　　 // 工作线程数量小于核心线程数，调用addWorker方法创建工作线程。
        // 提交任务command作为Worder的第一个任务执行。
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        //工作线程数量大于核心线程数且，线程池在运行则将任务加到队列 
       if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            //重新检查，如果线程池不在RUNNING，删除上一步加入队列的任务
            if (! isRunning(recheck) && remove(command))
                reject(command);
　　　　　　　// 线程池处于RUNNING状态 || 线程池处于非RUNNING状态但是任务移除失败
            else if (workerCountOf(recheck) == 0)
　　　　　　　// 线程池处于SHUTDOWN状态下，没有活动线程了，但是队列里还有任务没执行这种特殊情况。
            // 添加一个null任务是因为SHUTDOWN状态下，线程池不再接受新任务      
                addWorker(null, false);
        }
        //1、非RUNNING状态拒绝新的任务
        //2、队列满了启动新的线程失败，即工作线程数量大于最大线程数量（workCount > maximumPoolSize）
        else if (!addWorker(command, false))
            reject(command);
    }
```

简单介绍一下，一个任务提交给线程池后，线程池创建线程来执行提交任务的流程。

1. 当提交任务时，线程池中的来用执行任务的线程数小于corePoolSize（核心线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行第二2步。
2. 当提交任务时，线程池中的来用执行任务的线程数大于corePoolSize（核心线程数），如果workQueue（任务队列）没有满，则线程池会将提交的任务先保存在workQueue，等待线程池中的线程执行完其它已提交任务后会循环从workQueue中取出任务执行。否则执行第3步。
3. 当提交任务时线程池中的来用执行任务大于corePoolSize（核心线程数），且workQueue（任务队列）已满，但没有超过maximunPoolSize（最大线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行4。
4. 当提交任务时，线程池中的来用执行任务的线程数大于maximunPoolSize（最大线程数），执行线程池中配置的拒绝策略（RejectedExecutionHanlder）。

所以在设置ThreadPoolExecutor的参数时一定要特别小心，不建议采用很大的ArrayBlockQueue或不限大小的LinkedBlockQueue，同时corePoolSize也不应该设置过大。CUP密集的任务的话可以设置小一点(CUP数据+1这种)避免不必要的上下文切换；而对于IO密集的任务则corePoolSize则可以设置的大一点，可以避免长时间IO等待而CUP却空闲。threadFactory建议采用自己定义的，让其创建的线程容易区分，方便问题定位。

### 线程池有哪些状态，状态之间流转是什么样子的？


状态流程如下图：

[![](http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg)](https://malcolmszx.github.io/)

1. 新建(new)：新创建了一个线程对象。
2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
3. 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice），执行程序代码。
4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
5. 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 池程池中的线程哪个时间点被创建？

ThreadPoolExecutor中的线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？一般是任务被提交后，线程池会利用线程工厂去创建线程，但当线程池中线程数已为corePoolSize时或maxmumPoolSize时不会。也可以在任务提交前通过prestartCoreThread方法或prestartAllCoreThreads方法预先创建核心线程。具体可以参考这下这个图：

[![](http://jbcdn2.b0.upaiyun.com/2016/08/9c4b388bc7ccb6424e3ae5ca0d05df8d.png)](https://malcolmszx.github.io/)


### ThreadPoolExecutor中创建的线程哪个时间被启动？

addWorker创建了ThreadPoolExecutor中用于执行提交任务的线程，这个过程同时把任务与执行任务的线程封装到Worker对象中。同时addWorker还启动了用于执行任务的线程，而具体任务的执行，则代理给了ThreadPoolExecutor的runWorkers方法。创建后完，该线程就被启动。线程池中被创建的线程被封装到了Worker对象中，而Worker类又实现了Runnable接口，线程池中的线程又引用了worker。当线程被start后实际就有机会等待操作系统调度执行Worker类的run方法。

```
private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
 　　　　　　　// 线程池状态为非RUNNING　&&
　　　　　　　 // (线程池状态为非SHUTDOWN || firstTask不为null || 队列为空) 三者中的一者

　　　　　　　 // 组合一下分别是
　　　　　　　 // 1、线程池状态为非RUNNING && 线程池状态为非SHUTDOWN，
　　　　　　　 // 即，线程池状态为 (STOP || TIDYING || TERMINATED) 
　　　　　　　 // 此时线程池不在接受新的任务，通过addWorker新提交的任务会失败
　　　　　　　 
　　　　　　　 // 2、线程池状态为非RUNNING && firstTask不为null 
              // 即，线程池状态为 (SHUTDOWN || STOP || TIDYING || TERMINATED) && firstTask不为null
              // 此时线程池不在接受新的任务，但有处理队列里的任务，通过addWorker新提交的任务会失败

              // 3、线程池状态为非RUNNING && 队列为空
              // 即，线程池状态为(SHUTDOWN || STOP || TIDYING || TERMINATED)&& 队列为空 
              // 此时线程池不在接受新的任务，因为队列中没有任务要处理，
　　　　　　　　// 所以没必要调用addWorker(null, false)，创建新的线程去处理工作队列的任务

            if (rs >= SHUTDOWN &&s
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                       return false;
　　　　　　　// 线程池状态为RUNNING 或者　(线程池状态为SHUTDOWN状态，且队列中还有任务需要执行)

            for (;;) {
                int wc = workerCountOf(c);
　　　　　　　　　　//工作线程数过大最大值，或者超过核心线程数或超过最大线程数，都返回false
　　　　　　　　　　if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))
                    return false;
　　　　　　　　　　//原子方式设置线程池中线程数成功，则跳出重试的循环                
　　　　　　　　　　if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
　　　　　　　　　　// 如果线程池的状态发生变化则重试
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
　　　　　　　//创建worker对象，worker对象内部
             //利用线程工厂创建一个线程去执行提交的任务
　　　　　　　//这个线程的target　Runnable为　worker本身，
　　　　　　　//最终调用worker.run执行提交的任务

            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    int rs = runStateOf(ctl.get());
　　　　　　　　　　　　// 重新检测线程池的状态，在获取得锁前一步，线程池可能已被终止
　　　　　　　　　　　　// 线程池状态为RUNNING 或者　(线程池状态为SHUTDOWN状态，且队列中还有任务需要执行)
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                //worker添加成功
                if (workerAdded) {
　　　　　　　　　　　　//启动worker内部线程，worker内部线程的
　　　　　　　　　　　　//target Runnable为worker本身，
                    //将运行worker的run方法，run内部调用ThreadPoolExecutor.runWorkers方法
                    t.start();
                    workerStarted = true;
                }    
             }
        } finally {
 　　　　　　 //获取得锁前一步，线程池已被终止导致
            //workerAdded失败或线程没start。
            if (! workerStarted)
 　　　　　　　　　//会调用tryTerminate方法
                addWorkerFailed(w);
        }
        return workerStarted;
    }

```

