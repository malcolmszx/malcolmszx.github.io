---
layout:     post
title:  如何掌握JDK中的线程池
subtitle:  JDK中的线程池(http://blog.jobbole.com/104737/)
date:       2019-02-15
author:     BY Malcolmszx@gmail.com
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - JDK
    - ThreadPoolExecutor 
---

## 前言

Java1.5后引入的Executor框架的最大优点是把任务的提交和执行解耦，只需把Task描述清楚，然后提交即可。至于这个Task是怎么被执行的，被谁执行的，什么时候执行的，就全部交给线程池管理。

小案例 

```
import java.util.concurrent.*;
 
/**
 * Created by malcolmszx on 2019/02/15.
 */
public class ExecutorTest {
    static ExecutorService executor = Executors.newFixedThreadPool(10);
 
    public static void main(String[] args) throws Exception {
        Future<String> future = executor.submit(new Task());
        String result = future.get();
        System.out.println(result);
    }
 
    static class Task implements Callable<String> {
        @Override
        public String call() throws Exception {
            TimeUnit.SECONDS.sleep(10);
            return "A";
        }
    }
}
```
初始化一个线程池，提交一个任务，主线程的future.get()会阻塞线程直到任务执行完成。

### Executor框架成员

线程池实现框架中包含了一堆实现类，它们之间的关系如下，只有了解了各个类之间的关系，才能方便我们更好的理解线程池的实现。

[![](http://jbcdn2.b0.upaiyun.com/2016/08/b02b59e6133fbc20b0b8ec4c7df8c018.png)](https://malcolmszx.github.io/)

从图中可以看到Executor、ExecutorService、ScheduledExecutorService定义线程池接口，ThreadPoolExecutor和ScheduledThreadPoolExecutor是线程池的实现，前者是一个普通的线程池，后者一个定期调度的线程池，Executors是辅助工具，用以帮助我们快速定义线程池。

JDK并发包下面的线程池ThreadPoolExecutor是面试中经常被考查的点，ThreadPoolExecutor哪些是应该掌握的？下面抛出了几个问题。

1. ThreadPoolExecutor中常用参数有哪些，作用是什么？任务提交后，ThreadPoolExecutor会按照什么策略去创建线程用于执行提交任务？
2. ThreadPoolExecutor有哪些状态，状态之间是怎样流转的？
3. ThreadPoolExecutor线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？
4. ThreadPoolExecutor创建的线程哪个时间被启动？
5. ThreadPoolExecutor竟然是线程池那么他是如何做到重复利用线程的？
6. ThreadPoolExecutor创建的同一个线程同一时刻能执行多个任务吗？如果不能是通过什么机制保证ThreadPoolExecutor中的同一个线程只能执行完一个任务，才会执行另一个任务？
7. ThreadPoolExecutor关闭线程池的方法shutdown与shutdownNow的区别是什么？
8. 通过submit方法向ThreadPoolExecutor提交任务后，当所有的任务都执行完后不调用shutdown或shutdownNow方法有问题？
9. ThreadPoolExecutor有没有提供扩展点，方便在任务执行前或执行后做一些事情？
10. ThreadPoolExecutor线程池工具类Executors如何快速自定义线程池？

### ThreadPoolExecutor参数有哪些与创建线程策略

ThreadPoolExecutor参数

1. corePoolSize 线程池中核心线程数
2. maximumPoolSize 线程池中最大线程数
3. keepAliveTime 线程活动保持时间。指工作线程空闲后，继续保持存活的时间。默认情况下，这个参数只有在线程数大于corePoolSize时才起作用。所以，如果任务很多，且每个任务的执行时间比较短，可以调大keepAliveTime，提高线程的利用率。
4. workQueue 阻塞队列，当线程池中线程数超过corePoolSize时，用来保存等待执行的任务的阻塞队列。

在初始化线程池时，对阻塞队列的选择也很重要，jdk中提供了以下几个阻塞队列：

[1] ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO原则对元素进行排序。
[2] LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序元素，吞吐量通常要高于ArrayBlockingQuene。
[3] SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene。
[4] priorityBlockingQuene：具有优先级的无界阻塞队列。

5. threadFactory 创建线程的工厂。可以通过自定义线程工厂给每个线程设置有意义的名称。

   如guava提供的ThreadFactoryBuilder。
    ```
    new ThreadFactoryBuilder().setNameFormat("XX-task-%d").build();
    ```

6. RejectedExecutionHandler饱和策略。当阻塞队列满了且没有空闲的工作线程，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略在默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。不过，线程池提供了4种策略：

    1. AbortPolicy：直接抛出异常。
    2. CallerRunsPolicy：只用调用者所在的线程来运行任务。
    3. DiscardOldestPolicy：丢弃阻塞队列中最近的一个任务，并执行当前任务。
    4. DiscardPolicy：直接丢弃。

当然，也可以根据应用场景来实现RejectedExecutionHandler接口自定义饱和策略，如记录日志或持久化存储不能处理的任务。

创建线程策略

[![](https://liuzhihang.com/resources/concurrent/thread-pool.png)](https://malcolmszx.github.io/)

简单介绍一下，一个任务提交给线程池后，线程池创建线程来执行提交任务的流程。

1. 当提交任务时，线程池中的来用执行任务的线程数小于corePoolSize（核心线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行第二2步。
2. 当提交任务时，线程池中的来用执行任务的线程数大于corePoolSize（核心线程数），如果workQueue（任务队列）没有满，则线程池会将提交的任务先保存在workQueue，等待线程池中的线程执行完其它已提交任务后会循环从workQueue中取出任务执行。否则执行第3步。
3. 当提交任务时线程池中的来用执行任务大于corePoolSize（核心线程数），且workQueue（任务队列）已满，但没有超过maximunPoolSize（最大线程数），则线程池利用ThreadFacory（线程工厂）创建线程用于执行提交的任务。否则执行4。
4. 当提交任务时，线程池中的来用执行任务的线程数大于maximunPoolSize（最大线程数），执行线程池中配置的拒绝策略（RejectedExecutionHanlder）。

所以在设置ThreadPoolExecutor的参数时一定要特别小心，不建议采用很大的ArrayBlockQueue或不限大小的LinkedBlockQueue，同时corePoolSize也不应该设置过大。CUP密集的任务的话可以设置小一点(CUP数据+1这种)避免不必要的上下文切换；而对于IO密集的任务则corePoolSize则可以设置的大一点，可以避免长时间IO等待而CUP却空闲。threadFactory建议采用自己定义的，让其创建的线程容易区分，方便问题定位。

### 线程池有哪些状态，状态之间流转是什么样子的？


状态流程如下图：

[![](http://static.oschina.net/uploads/space/2013/0621/174442_0BNr_182175.jpg)](https://malcolmszx.github.io/)


1. 新建(new)：新创建了一个线程对象。
2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。
3. 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice），执行程序代码。
4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 
(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。
(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。
5. 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。

### 池程池中的线程哪个时间点被创建？

ThreadPoolExecutor中的线程哪个时间点被创建？是任务提交后吗？可以在任务提交前创建吗？一般是任务被提交后，线程池会利用线程工厂去创建线程，但当线程池中线程数已为corePoolSize时或maxmumPoolSize时不会。也可以在任务提交前通过prestartCoreThread方法或prestartAllCoreThreads方法预先创建核心线程。具体可以参考这下这个图：

[![](http://jbcdn2.b0.upaiyun.com/2016/08/9c4b388bc7ccb6424e3ae5ca0d05df8d.png)](https://malcolmszx.github.io/)


### ThreadPoolExecutor中创建的线程哪个时间被启动？

线程池中线程实现是在addWorker方法中被创建的，详见之前文章中addWorker方法分析。创建后完，该线程就被启动。线程池中被创建的线程被封装到了Worker对象中，而Worker类又实现了Runnable接口，线程池中的线程又引用了worker。当线程被start后实际就有机会等待操作系统调度执行Worker类的run方法。

```
Worker(Runnable firstTask) {
  setState(-1); 
  this.firstTask = firstTask;
 //创建的线程引用了worker
  this.thread = getThreadFactory().newThread(this);
}

```

